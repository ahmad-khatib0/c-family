Standard data types in C++ include the following:
• int: To store whole numbers
• float: To store floating point values
• double: To store double precision floating point values
• char: To store a single character
• bool: For boolean values of true or false

== It is important to note that the C++ community is moving away from native C++ strings 
   that is, those implemented using an array of (or pointer to) characters.

The iostream library
  cin can be used in conjunction with the extraction operator >> for buffered input
  cout can be used in conjunction with the insertion operator << for buffered output
  cerr (unbuffered) and clog (buffered) can also be used in conjunction with the insertion 
  operator, but for errors

Basic iostream manipulators (defined in the <iomanip> header file.): 
• endl: Places a newline character ('\n') in the buffer associated with cout then flushes 
  the buffer
• flush: Clears the contents of the output stream
• setprecision(int): Defines the precision (number of digits) used to output floating point 
  numbers
• setw(int): Sets the width for input and output
• ws: Removes whitespace characters from the buffer

== A related historical note, #define (a preprocessor directive and macro replacement) was 
   once used to create more mnemonic types, but typedef (and using) are certainly preferred.
   It’s worthy to note when viewing older code. 
   A using statement can be used as an alternative to a simple typedef to create an alias 
   for a type, known as an alias-declaration. The using statement can also be used to simplify 
   more complex types (such as providing an alias for complex declarations when using the 
   Standard Template Library or declaring function pointers). The current trend is to favor 
   a using alias-declaration to a typedef.

A pointer variable may point to the existing memory of a non-pointer variable, or it may point
  to memory that is dynamically allocated on the heap. The latter case is the most usual 
  situation. Unless a pointer variable is properly initialized or assigned a value, the 
  content of the pointer variable is meaningless and does not represent a usable address. 
  A large mistake can be assuming that a pointer variable has been properly initialized 
  when it may not have been. 

Using const qualification with function parameters cannot just allow the speed of passing an
  argument by reference, but the safety of passing an argument by value. It is a useful 
  feature in C++.

References are implemented as constant pointers, hence they must be initialized. Once 
  initialized, references may not refer to a different object (though the value of the 
  object being referenced can be changed).

Even though a reference is implemented as a constant pointer, the usage of the reference 
  variable is as if the underlying constant pointer has been dereferenced. For this reason, 
  you cannot initialize a reference with a nullptr – not only can a nullptr not be dereferenced
  but since references can only be initialized and not reset, the opportunity would be lost 
  to establish the reference variable to refer to a meaningful object. This also holds true 
  for references to pointers.

Understanding when we must use pointers instead of references?
  Based on the underlying implementation of references (as const pointers), most of the 
  restrictions for reference usage make sense. For example, references to references are 
  generally not allowed; each level of indirection would need to be initialized upfront and 
  that often takes multiple steps, such as when using pointers. However, we will see r-value 
  references (&&) in Chapter 15, Testing Classes and Components, where we will examine various 
  move operations. Arrays of references are also not permitted (each element would need to be 
  initialized immediately); nonetheless, arrays of pointers are always an option. Also, pointers 
  to references are not permitted; however, references to pointers are permitted (as are 
  pointers to pointers).

In some OO languages, the term method is used more loosely to imply either the operation or
  its method, based on the context of usage. In C++, the terms data member and member 
  function are most often used.

C++ structures may also be used to encapsulate data and their related behaviors. A C++ struct
  can do anything a C++ class can do; in fact, class is implemented in terms of struct in C++.
  Though structures and classes may behave identically (other than default visibility), 
  classes are more often used to model objects, relationships between object types, and 
  implement object-oriented systems.

It is interesting to note that data members, when grouped into an access region collectively
  under the same access label, are guaranteed to be laid out in memory in the order specified.
  However, if multiple access regions exist containing data members within a given class, 
  the compiler is free to reorder those respective groupings for efficient memory layout.

- A destructor is a member function whose purpose is to relinquish the resources an object 
  may have acquired during its existence. A destructor is automatically invoked when a 
  class or struct instance has either of the following occur:
    • Goes out of scope (this applies to non-pointer variables)
    • Is explicitly deallocated using delete (for pointers to objects)
    • Both classes and structures may have destructors.

- Are virtual destructors always necessary? That is a good question! Virtual destructors 
  are always necessary when using a public base class hierarchy, that is, when using public 
  inheritance. Recall that public base classes support Is-A relationships, which easily lead
  to allowing a derived class instance to be stored using a pointer of its base class type.
  For example, a GraduateStudent Is-A Student, so we can store a GraduateStudent as a Student 
  in times when we require more generic processing along with its sibling types. We can always
  upcast in this fashion across a public inheritance boundary. However, when we use implementation 
  inheritance (that is, private or protected base classes), upcasting is not allowed. So, for
  hierarchies employing private or protected inheritance, virtual destructors are not necessary
  because upcasting is simply disallowed; hence, it would never be ambiguous as to which 
  destructor should be the entry point for classes in private and protected base class 
  hierarchies.

- When a base class specifies one or more new virtual functions (not just redefinitions of an 
  ancestor’s virtual functions), a virtual function pointer (vptr) is created below the memory
  comprising a given instance of that type. This happens at runtime when the memory for an 
  instance is created (on the stack, heap, or static/extern area). When the instance in 
  question is constructed, not only will the appropriate constructor be called to initialize 
  the instance, but this vptr will be initialized to point to the virtual function pointer 
  table (v-table) entry for that class type. The v-table entry for a given class type will 
  consist of a set of function pointers. These function pointers are often organized into an
  array of function pointers. A function pointer is a pointer to an actual function. By 
  dereferencing this pointer, you will actually invoke the function to which the pointer
  points. There is an opportunity to pass arguments to the function, however, in order for 
  this call to be generic through a function pointer, the arguments must be uniform for any 
  version of this function that the pointer in question may point to. The premise of a function
  pointer gives us the ability to point to different versions of a particular function. That 
  is, we could point to different methods for a given operation. This is the basis for which 
  we can automate dynamic binding in C++ for virtual functions.

- A discriminator is an object-oriented concept that helps outline the reasons why a given
  class is derived from its base class. Discriminators tend to characterize the types of 
  groupings of specializations that exist for a given base class.

- Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining the
  discriminators can help us decide whether the design is reasonable, or whether perhaps 
  an alternate design would prove better. Here are some good design metrics to consider:
  . If the discriminators for the sibling classes that are being brought back together are
    the same, then the diamond-shaped hierarchy is better off redesigned.
  . When the sibling classes do not have unique discriminators, the attributes and behaviors
    they will introduce will consist of duplications stemming from having a like-discriminator.
    Consider making the discriminator a class to house those commonalities.
  . If the discriminators for the sibling classes are unique, then the diamond-shaped 
    hierarchy may be warranted. In this case, virtual base classes will prove helpful and 
    should be added to the appropriate locations in the hierarchy.

