Standard data types in C++ include the following:
• int: To store whole numbers
• float: To store floating point values
• double: To store double precision floating point values
• char: To store a single character
• bool: For boolean values of true or false

== It is important to note that the C++ community is moving away from native C++ strings 
   that is, those implemented using an array of (or pointer to) characters.

The iostream library
  cin can be used in conjunction with the extraction operator >> for buffered input
  cout can be used in conjunction with the insertion operator << for buffered output
  cerr (unbuffered) and clog (buffered) can also be used in conjunction with the insertion 
  operator, but for errors

Basic iostream manipulators (defined in the <iomanip> header file.): 
• endl: Places a newline character ('\n') in the buffer associated with cout then flushes 
  the buffer
• flush: Clears the contents of the output stream
• setprecision(int): Defines the precision (number of digits) used to output floating point 
  numbers
• setw(int): Sets the width for input and output
• ws: Removes whitespace characters from the buffer

== A related historical note, #define (a preprocessor directive and macro replacement) was 
   once used to create more mnemonic types, but typedef (and using) are certainly preferred.
   It’s worthy to note when viewing older code. 
   A using statement can be used as an alternative to a simple typedef to create an alias 
   for a type, known as an alias-declaration. The using statement can also be used to simplify 
   more complex types (such as providing an alias for complex declarations when using the 
   Standard Template Library or declaring function pointers). The current trend is to favor 
   a using alias-declaration to a typedef.

A pointer variable may point to the existing memory of a non-pointer variable, or it may point
  to memory that is dynamically allocated on the heap. The latter case is the most usual 
  situation. Unless a pointer variable is properly initialized or assigned a value, the 
  content of the pointer variable is meaningless and does not represent a usable address. 
  A large mistake can be assuming that a pointer variable has been properly initialized 
  when it may not have been. 

Using const qualification with function parameters cannot just allow the speed of passing an
  argument by reference, but the safety of passing an argument by value. It is a useful 
  feature in C++.

References are implemented as constant pointers, hence they must be initialized. Once 
  initialized, references may not refer to a different object (though the value of the 
  object being referenced can be changed).

Even though a reference is implemented as a constant pointer, the usage of the reference 
  variable is as if the underlying constant pointer has been dereferenced. For this reason, 
  you cannot initialize a reference with a nullptr – not only can a nullptr not be dereferenced
  but since references can only be initialized and not reset, the opportunity would be lost 
  to establish the reference variable to refer to a meaningful object. This also holds true 
  for references to pointers.

Understanding when we must use pointers instead of references?
  Based on the underlying implementation of references (as const pointers), most of the 
  restrictions for reference usage make sense. For example, references to references are 
  generally not allowed; each level of indirection would need to be initialized upfront and 
  that often takes multiple steps, such as when using pointers. However, we will see r-value 
  references (&&) in Chapter 15, Testing Classes and Components, where we will examine various 
  move operations. Arrays of references are also not permitted (each element would need to be 
  initialized immediately); nonetheless, arrays of pointers are always an option. Also, pointers 
  to references are not permitted; however, references to pointers are permitted (as are 
  pointers to pointers).

In some OO languages, the term method is used more loosely to imply either the operation or
  its method, based on the context of usage. In C++, the terms data member and member 
  function are most often used.

C++ structures may also be used to encapsulate data and their related behaviors. A C++ struct
  can do anything a C++ class can do; in fact, class is implemented in terms of struct in C++.
  Though structures and classes may behave identically (other than default visibility), 
  classes are more often used to model objects, relationships between object types, and 
  implement object-oriented systems.

It is interesting to note that data members, when grouped into an access region collectively
  under the same access label, are guaranteed to be laid out in memory in the order specified.
  However, if multiple access regions exist containing data members within a given class, 
  the compiler is free to reorder those respective groupings for efficient memory layout.

- A destructor is a member function whose purpose is to relinquish the resources an object 
  may have acquired during its existence. A destructor is automatically invoked when a 
  class or struct instance has either of the following occur:
    • Goes out of scope (this applies to non-pointer variables)
    • Is explicitly deallocated using delete (for pointers to objects)
    • Both classes and structures may have destructors.

- Are virtual destructors always necessary? That is a good question! Virtual destructors 
  are always necessary when using a public base class hierarchy, that is, when using public 
  inheritance. Recall that public base classes support Is-A relationships, which easily lead
  to allowing a derived class instance to be stored using a pointer of its base class type.
  For example, a GraduateStudent Is-A Student, so we can store a GraduateStudent as a Student 
  in times when we require more generic processing along with its sibling types. We can always
  upcast in this fashion across a public inheritance boundary. However, when we use implementation 
  inheritance (that is, private or protected base classes), upcasting is not allowed. So, for
  hierarchies employing private or protected inheritance, virtual destructors are not necessary
  because upcasting is simply disallowed; hence, it would never be ambiguous as to which 
  destructor should be the entry point for classes in private and protected base class 
  hierarchies.

- When a base class specifies one or more new virtual functions (not just redefinitions of an 
  ancestor’s virtual functions), a virtual function pointer (vptr) is created below the memory
  comprising a given instance of that type. This happens at runtime when the memory for an 
  instance is created (on the stack, heap, or static/extern area). When the instance in 
  question is constructed, not only will the appropriate constructor be called to initialize 
  the instance, but this vptr will be initialized to point to the virtual function pointer 
  table (v-table) entry for that class type. The v-table entry for a given class type will 
  consist of a set of function pointers. These function pointers are often organized into an
  array of function pointers. A function pointer is a pointer to an actual function. By 
  dereferencing this pointer, you will actually invoke the function to which the pointer
  points. There is an opportunity to pass arguments to the function, however, in order for 
  this call to be generic through a function pointer, the arguments must be uniform for any 
  version of this function that the pointer in question may point to. The premise of a function
  pointer gives us the ability to point to different versions of a particular function. That 
  is, we could point to different methods for a given operation. This is the basis for which 
  we can automate dynamic binding in C++ for virtual functions.

- A discriminator is an object-oriented concept that helps outline the reasons why a given
  class is derived from its base class. Discriminators tend to characterize the types of 
  groupings of specializations that exist for a given base class.

- Whenever temptation leads to the creation of a diamond-shaped hierarchy, examining the
  discriminators can help us decide whether the design is reasonable, or whether perhaps 
  an alternate design would prove better. Here are some good design metrics to consider:
  . If the discriminators for the sibling classes that are being brought back together are
    the same, then the diamond-shaped hierarchy is better off redesigned.
  . When the sibling classes do not have unique discriminators, the attributes and behaviors
    they will introduce will consist of duplications stemming from having a like-discriminator.
    Consider making the discriminator a class to house those commonalities.
  . If the discriminators for the sibling classes are unique, then the diamond-shaped 
    hierarchy may be warranted. In this case, virtual base classes will prove helpful and 
    should be added to the appropriate locations in the hierarchy.

-- Utilizing backlink maintenance and reference counting
   For example, consider the Student and Course relationship. A Student is enrolled in many
   Course instances. A Course contains an association to many Student instances. This is a 
   many-to-many association. Let’s imagine that the Student wishes to drop a Course. It is 
   not enough for a specific Student instance to remove a pointer to a specific Course 
   instance. Additionally, the Student must let the particular Course instance know that 
   the Student in question should be removed from that Course’s roster. This is known as 
   backlink maintenance.

- One idea to help us with overall link maintenance is to consider reference counting. 
  The purpose of reference counting is to keep track of how many pointers may be pointing
  to a given instance. For example, if other objects point to a given instance, that 
  instance should not be deleted. Otherwise, the pointers in the other object will point 
  to deallocated memory, which will lead to numerous runtime errors.

- Friend functions are functions that are individually granted extended scope to include 
  the class with which they are associated. Let’s examine the implications and logistics:
  • In the scope of friend functions, an instance of the associated type can access its 
    own members as if it were in the scope of its own class.
  • A friend function needs to be prototyped as a friend in the class definition of the 
    class relinquishing access (that is, extending its scope).
  • The keyword friend is used in front of the prototype that provides access.
  • Functions overloading friend functions are not considered friends.

- Friend classes are classes in which every member function of the class is a friend 
  function of the associated class. Let’s examine the logistics:
  • A friend class should have a forward declaration in the class definition of the class
    that is providing it with access to its members (that is, scope).
  • The keyword friend should precede the forward declaration of the class gaining 
    access (that is, whose scope has been extended).

- Not all operators may be overloaded in C++. The following operators cannot be 
  overloaded: the member access operator (.), the ternary conditional operator (?:), 
  the scope resolution operator ( ::), the pointer-to-member operator (.*), the sizeof()
  operator, and the typeid() operator. All the rest may be overloaded, provided at least 
  one operand is a user defined type.

- The Standard Template Library(STL) in C++ is a library of standard classes and utilities 
  that extend the C++ language. The use of the STL is so pervasive that it is as though 
  the STL is a part of the language itself; it is an essential and integral part of C++.
  The STL in C++ has four key components comprising the library: containers, iterators, 
  functions, and algorithms.

- There are several categories of container classes – sequential, associative, and 
  unordered. Let’s summarize these categories and provide a few examples of each:
  • Sequential containers: Implement encapsulated data structures that can be accessed 
    in a sequential manner, such as list, queue, or stack. It is interesting to note that 
    queue and stack can be thought of as a customized or adaptive interface for a more basic
    container, such as a list. Nonetheless, a queue and stack still provide sequential 
    access to their elements.
  • Associative containers: Implement sorted, encapsulated data structures that 
    can be searched quickly to retrieve an element such as set or map.
  • Unordered containers: Implement unordered, encapsulated data structures that 
    can be searched reasonably quickly, such as unordered_set or unordered_map.

